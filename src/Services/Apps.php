<?php

namespace DT\Home\Services;

use DT\Home\Sources\SettingsApps;
use DT\Home\Sources\UserApps;
use function DT\Home\container;
use function DT\Home\set_plugin_option;
use function DT\Home\get_magic_url;

/**
 * Queries apps from multiple sources,
 * and may add business logic that the app sources do not.
 */
class Apps {
    private MagicApps $magic_apps;

    public function __construct( MagicApps $magic_apps )
    {
        $this->magic_apps = $magic_apps;
    }

    /**
     * Save apps.
     *
     * @param array $apps The apps to be saved.
     * @return bool Whether the saving was successful or not.
     */
    public function save( $apps ): bool {
        return set_plugin_option( 'apps', array_values( $apps ) );
    }

    /**
	 * Retrieve all apps from the option and sort them based on the 'sort' key.
	 *
	 * @return array The sorted array of apps.
	 */
    public function all() {
		// Get the apps array from the option
		$db_apps = get_option( 'dt_home_apps', [] );
        $filtered_apps = apply_filters( 'dt_home_apps', [] );

        /**
         * Remove stale coded-apps; no longer present within filter calls.
         */

        // Identify coded apps currently stored within db.
        $db_coded_apps = array_filter( $db_apps, function ( $app ) {
            return ( isset( $app['creation_type'] ) && ( $app['creation_type'] === 'code' ) );
        } );

        // Identify coded apps currently generated by filters.
        $filtered_coded_apps = array_filter( $filtered_apps, function ( $app ) {
            return ( isset( $app['creation_type'] ) && ( $app['creation_type'] === 'code' ) );
        } );

        // Identify db coded apps, no longer generated by filter call.
        $diff_coded_apps = array_udiff( $db_coded_apps, $filtered_coded_apps, function ( $a, $b ) {
            return strcmp( ( $a['slug'] ?? '' ), ( $b['slug'] ?? '' ) );
        } );

        // Remove any identified stale coded apps from db.
        if ( !empty( $diff_coded_apps ) ) {

            // Unset based on original keys.
            foreach ( $diff_coded_apps as $key => $app ) {
                unset( $db_apps[ $key ] );
            }

            // Reindex array elements and persist changes to db.
            $this->save( $db_apps );
        }

        // Merge updated apps; for further downstream processing.
        $apps = [];
        foreach ( $filtered_apps as $app ) {
            $this->merge_coded_app( $apps, $app );
        }
        foreach ( $db_apps as $app ) {
            $this->merge_db_app( $apps, $app );
        }

		// Sort the array based on the 'sort' key
		usort($apps, function ( $a, $b ) {
			return ( (int) $a['sort'] ?? 0 ) - ( (int) $b['sort'] ?? 0 );
		});

		return $this->format( $apps );
	}

    private function format( $apps ) {
		$apps = array_map(function ( $app ) {
			return array_merge([
				'name' => '',
				'type' => 'Web View',
                'creation_type' => 'custom',
				'icon' => '',
				'url' => '',
				'sort' => 0,
				'slug' => '',
				'is_hidden' => false,
			], $app);
		}, $apps);

		return $apps;
	}

    /**
	 * Retrieve the apps array for a specific user.
	 * If the user has a specific apps array set, it will be returned.
	 * Otherwise, the default apps array will be returned.
	 *
	 * @param int $user_id The ID of the user.
	 *
	 * @return array The apps array for the user.
	 */
	public function for_user( $user_id ) {

        $user_apps = get_user_option( 'dt_home_apps', $user_id );
		if ( ! $user_apps ) {
			$user_apps = [];
		}
		$apps = $this->all();

		foreach ( $apps as $idx => $app ) {
			$matching_user_apps = array_filter( $user_apps, function ( $user_app ) use ( $app ) {
				return ( $user_app['slug'] ?? '' ) === ( $app['slug'] ?? '' );
			} );

			if ( ! empty( $matching_user_apps ) ) {
                $user_app = reset( $matching_user_apps );

				$apps[ $idx ] = array_merge(
					$app,
					[
                        'is_hidden' => $user_app['is_hidden'] ?? false,
                        'sort' => $user_app['sort'] ?? 0,
                    ]
				);
			}

            // If required, source correct user keys for magic link app urls.
            if ( !empty( $app['magic_link_meta'] ) && isset( $app['magic_link_meta']['post_type'], $app['magic_link_meta']['root'], $app['magic_link_meta']['type'] ) ) {
                switch ( $app['magic_link_meta']['post_type'] ) {
                    case 'user':
                        $apps[ $idx ]['url'] = get_magic_url( $app['magic_link_meta']['root'], $app['magic_link_meta']['type'], $user_id );
                        break;
                    case 'contacts':
                        $apps[ $idx ]['url'] = get_magic_url( $app['magic_link_meta']['root'], $app['magic_link_meta']['type'], \Disciple_Tools_Users::get_contact_for_user( $user_id ) );
                        break;
                }
            }
        }

        $apps = array_filter( $apps, function ( $app ) {
            return ( $app['is_deleted'] ?? false ) === false;
        });
		// Sort the array based on the 'sort' key
		usort($apps, function ( $a, $b ) {
			return ( (int) $a['sort'] ?? 0 ) - ( (int) $b['sort'] ?? 0 );
		});

		return $apps;
	}

    /**
     * Get all apps from the specified app source classname.
     *
     * @param string $app_source The class name of the app source.
     * @param array $params Optional parameters for filtering the apps.
     */
    public function from( $app_source, array $params = [] ) {
        $aggregator = new Aggregator( [
            $app_source
        ]);
        return $aggregator->all( $params );
    }

    /**
     * Alias for from method.
     *
     * @param string $app_source
     * @param array $params
     * @return array
     */
    public function source( $app_source, array $params = [] ) {
        return $this->from( $app_source, $params );
    }

    /**
     * Retrieve the apps array for a specific user.
     *
     * If the user has a specific apps array set, it will be returned.
     *
     * @param int $user_id The ID of the user.
     * @param array $params Optional parameters for filtering the apps.
     */
    public function for( int $user_id = 0, array $params = [] ) {
        if ( $user_id === 0 ) {
            $user_id = get_current_user_id();
        }
        $params['user_id'] = $user_id;
        $apps = $this->from( UserApps::class, $params );

        // Filter out apps; which the user does not currently have permission to access and reindex.
        $roles_permissions_srv = container()->get( RolesPermissions::class );
        $dt_custom_roles = get_option( $roles_permissions_srv::OPTION_KEY_CUSTOM_ROLES, [] );
        $apps = array_values( array_filter( $apps, function ( $app ) use ( $user_id, $roles_permissions_srv, $dt_custom_roles ) {
            return $roles_permissions_srv->has_permission( $app, $user_id, $dt_custom_roles );
        } ) );

        // Proceed with hydration of magic link urls.
        $this->magic_apps->hydrate_magic_urls( $apps, $user_id );
        return $apps;
    }

    /**
     * Find an app for a specific user by the app's slug.
     *
     * @param string $slug The slug of the app.
     * @param int $user_id The ID of the user.
     * @param array $params Optional parameters for filtering the apps.
     * @return array|null The app with matching slug for the user, or null if not found.
     */
    public function find_for( string $slug, int $user_id, array $params = [] )
    {
        if ( $user_id === 0 ) {
            $user_id = get_current_user_id();
        }
        $params['user_id'] = $user_id;
        $service = SourceFactory::make( UserApps::class );
        $app = $service->find( $slug, $params );
		if ( ! $app ) {
			return null;
		}
        $this->magic_apps->hydrate_magic_url( $app, $user_id );
        return $app;
    }

    /**
     * Find an app by slug.
     *
     * @param string $slug The slug of the app.
     * @return array|null The app with matching slug, or null if not found.
     */
    public function find( string $slug, array $params = [] ) {
        $source = $params['source'] ?? SettingsApps::class;
        $apps = $this->from( $source, $params );
        return $this->first_with_slug( $apps, $slug );
    }

    /**
     * Confirm app slug exists.
     *
     * @param string $slug The slug of the app.
     * @return bool
     */
    public function has( string $slug ): bool {
        return !empty( $this->find( $slug ) );
    }

    /**
     * Move identified app in the specified direction.
     *
     * @param string $slug
     * @param string $direction
     * @return bool
     */
    public function move( string $slug, string $direction ): bool {
        if ( $this->has( $slug ) ) {
            $key = 'sort';
            $settings_apps = container()->get( SettingsApps::class );

            // Fetch all apps in ascending order, with reset sort counts.
            $apps = $settings_apps->sort( $this->from( SettingsApps::class ), [
                'reset' => true,
            ] );

            // Adjust sort count for specified app.
            $apps = array_map( function ( $app ) use ( $slug, $direction, $key ) {
                if ( $slug === $app['slug'] ?? '' ) {

                    /**
                     * Increment or Decrement accordingly by a couple hops, to
                     * ensure new sort position falls on the lower or upper
                     * side of adjacent app; based on specified direction.
                     */

                    switch ( $direction ){
                        case 'up':
                            $app[ $key ] -= 2;
                            break;
                        case 'down':
                            $app[ $key ] += 2;
                            break;
                    }
                }

                return $app;
            }, $apps );

            // Refresh counts following adjustments.
            $apps = $settings_apps->sort( $apps, [
                'reset' => true,
            ] );

            // Save updated apps list.
            return $settings_apps->save( $apps );
        }

        return false;
    }

    /**
     * Import specified apps; creating or updating accordingly, based on incoming slugs.
     *
     * @param array $importing_apps
     *
     * @return bool
     */
    public function import( array $importing_apps ): bool
    {
        $required_properties = [ 'slug', 'name', 'icon', 'type', 'url' ];

        // Filter out valid apps, suitable for import.
        $filtered_apps = array_filter( $importing_apps, function ( $app ) use ( $required_properties ) {

            // Ensure required properties are present.
            return count( $required_properties ) === count( array_intersect( $required_properties, array_keys( $app ) ) );
        } );

        if ( empty( $filtered_apps ) ) {
            return false;
        }

        // Ensure key internal properties, are also present within importing apps.
        $filtered_apps = array_map( function ( $filtered_app ) {
            return array_merge( [
                'creation_type' => 'custom',
                'source' => 'settings',
                'sort' => 10,
                'is_hidden' => false,
                'is_deleted' => false,
                'open_in_new_tab' => true,
                'roles' => []
            ], $filtered_app );
        }, $filtered_apps );

        // Fetch existing system apps.
        $existing_apps = $this->from( SettingsApps::class );

        // Extract array of importing slug ids.
        $importing_slugs = array_map( function ( $app ) {
            return $app['slug'];
        }, $filtered_apps );

        // Proceed with import and reshaping of existing apps.
        $updated_apps = $filtered_apps;
        foreach ( $existing_apps as $existing_app ) {
            if ( !in_array( $existing_app['slug'], $importing_slugs ) ) {
                $updated_apps[] = $existing_app;
            }
        }

        // Save updated apps list.
        return container()->get( SettingsApps::class )->save( $updated_apps );
    }

    /**
     * Returns the first element of the given array or null if the array is empty.
     *
     * @param array $apps The input array.
     * @return mixed|null The first element of the array or null if the array is empty.
     */
    private function first( array $apps ) {
        return !empty( $apps ) ? $apps[0] : null;
    }

    /**
     * Filter the apps array by slug and return an array of matching items.
     * @param array $apps
     * @param string $slug
     * @return array
     */
    private function with_slug( array $apps, string $slug ): array
    {
        return $this->filter( $apps, 'slug', $slug );
    }

    /**
     * Filter the apps array to find the items with matching key and value.
     *
     * @param array $apps The array of apps.
     * @param string $key The key to check for a match.
     * @param mixed $value The value to check for a match.
     *
     * @return array The filtered array of apps with matching key and value.
     */
    private function filter( array $apps, string $key, $value ): array
    {
        // Filter the $apps array to find the item with matching key and value.
        $filtered_apps = array_filter($apps, function ( $app ) use ( $key, $value ) {
            return ( $app[$key] ?? '' ) === $value;
        });

        // array_filter preserves array keys, so use array_values to reindex it
        return array_values( $filtered_apps );
    }


    /**
     * Get the first app from the apps array with the given slug.
     */
    private function first_with_slug( $apps, $slug )
    {
        $filtered_apps = $this->with_slug( $apps, $slug );
        return $this->first( $filtered_apps );
    }

    /**
     * Merge a coded app into the apps array.
     * It should take precedence over any existing app with the same slug.
     * @param array $apps
     * @param array $app
     * @return void
     */
    private function merge_coded_app( array &$apps, array $app ) {
        $existing = $apps[ $app['slug'] ] ?? [];
        $apps[ $app['slug'] ] = array_merge( $existing, $app );
    }

    /**
     * Merge a db app into the apps array.
     * We need to be sure not to overwrite any existing coded app urls
     * and magic link meta
     * @param array $apps
     * @param array $app
     * @return void
     */
    private function merge_db_app( &$apps, $app ) {
        $existing = $apps[ $app['slug'] ] ?? [];
        $type = $existing['creation_type'] ?? 'custom';

        //If there is no existing app or the existing app is not a coded app, just merge the app
        if ( ( ! isset( $apps[ $app['slug'] ] ) )
            || ( $type !== 'code' ) ) {
            $apps[ $app['slug'] ] = array_merge( $existing, $app );
            return;
        }

        //If the existing app is a coded app, we need to keep the url and magic link meta
        $overrides = [
            'url' => $existing['url'] ?? ''
        ];
        if ( isset( $app['magic_link_meta'] ) ) {
            $overrides['magic_link_meta'] = $app['magic_link_meta'];
        }

        //Merge the app with the overrides
        $apps[ $app['slug'] ] = array_merge( $existing, $app, $overrides );
    }
}
