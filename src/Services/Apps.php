<?php

namespace DT\Home\Services;

use function DT\Home\get_magic_url;
use function DT\Home\set_plugin_option;

class Apps {
    /**
     * Save apps.
     *
     * @param array $apps The apps to be saved.
     * @return bool Whether the saving was successful or not.
     */
    public function save( $apps ): bool {
        return set_plugin_option( 'apps', array_values( $apps ) );
    }

	/**
	 * Retrieve all apps from the option and sort them based on the 'sort' key.
	 *
	 * @return array The sorted array of apps.
	 */
	public function all() {
		// Get the apps array from the option
		$db_apps = get_option( 'dt_home_apps', [] );
        $filtered_apps = apply_filters( 'dt_home_apps', [] );

        /**
         * Remove stale coded-apps; no longer present within filter calls.
         */

        // Identify coded apps currently stored within db.
        $db_coded_apps = array_filter( $db_apps, function ( $app ) {
            return ( isset( $app['creation_type'] ) && ( $app['creation_type'] === 'code' ) );
        } );

        // Identify coded apps currently generated by filters.
        $filtered_coded_apps = array_filter( $filtered_apps, function ( $app ) {
            return ( isset( $app['creation_type'] ) && ( $app['creation_type'] === 'code' ) );
        } );

        // Identify db coded apps, no longer generated by filter call.
        $diff_coded_apps = array_udiff( $db_coded_apps, $filtered_coded_apps, function ( $a, $b ) {
            return strcmp( ( $a['slug'] ?? '' ), ( $b['slug'] ?? '' ) );
        } );

        // Remove any identified stale coded apps from db.
        if ( !empty( $diff_coded_apps ) ) {

            // Unset based on original keys.
            foreach ( $diff_coded_apps as $key => $app ) {
                unset( $db_apps[ $key ] );
            }

            // Reindex array elements and persist changes to db.
            $this->save( $db_apps );
        }

        // Merge updated apps; for further downstream processing.
        $apps = [];
        foreach ( $filtered_apps as $app ) {
            $this->merge_coded_app( $apps, $app );
        }
        foreach ( $db_apps as $app ) {
            $this->merge_db_app( $apps, $app );
        }

		// Sort the array based on the 'sort' key
		usort($apps, function ( $a, $b ) {
			return ( (int) $a['sort'] ?? 0 ) - ( (int) $b['sort'] ?? 0 );
		});

		return $this->format( $apps );
	}

	/**
	 * Retrieve the apps array for a specific user.
	 * If the user has a specific apps array set, it will be returned.
	 * Otherwise, the default apps array will be returned.
	 *
	 * @param int $user_id The ID of the user.
	 *
	 * @return array The apps array for the user.
	 */
	public function for_user( $user_id ) {

        $user_apps = get_user_option( 'dt_home_apps', $user_id );
		if ( ! $user_apps ) {
			$user_apps = [];
		}
		$apps = $this->all();

		foreach ( $apps as $idx => $app ) {
			$matching_user_apps = array_filter( $user_apps, function ( $user_app ) use ( $app ) {
				return ( $user_app['slug'] ?? '' ) === ( $app['slug'] ?? '' );
			} );

			if ( ! empty( $matching_user_apps ) ) {
                $user_app = reset( $matching_user_apps );

				$apps[ $idx ] = array_merge(
					$app,
					[
                        'is_hidden' => $user_app['is_hidden'] ?? false,
                        'sort' => $user_app['sort'] ?? 0,
                    ]
				);
			}

            // If required, source correct user keys for magic link app urls.
            if ( !empty( $app['magic_link_meta'] ) && isset( $app['magic_link_meta']['post_type'], $app['magic_link_meta']['root'], $app['magic_link_meta']['type'] ) ) {
                switch ( $app['magic_link_meta']['post_type'] ) {
                    case 'user':
                        $apps[ $idx ]['url'] = get_magic_url( $app['magic_link_meta']['root'], $app['magic_link_meta']['type'], $user_id );
                        break;
                    case 'contacts':
                        $apps[ $idx ]['url'] = get_magic_url( $app['magic_link_meta']['root'], $app['magic_link_meta']['type'], \Disciple_Tools_Users::get_contact_for_user( $user_id ) );
                        break;
                }
            }
        }

        $apps = array_filter( $apps, function ( $app ) {
            return ( $app['is_deleted'] ?? false ) === false;
        });
		// Sort the array based on the 'sort' key
		usort($apps, function ( $a, $b ) {
			return ( (int) $a['sort'] ?? 0 ) - ( (int) $b['sort'] ?? 0 );
		});

		return $apps;
	}

	private function format( $apps ) {
		$apps = array_map(function ( $app ) {
			return array_merge([
				'name' => '',
				'type' => 'Web View',
                'creation_type' => 'custom',
				'icon' => '',
				'url' => '',
				'sort' => 0,
				'slug' => '',
				'is_hidden' => false,
			], $app);
		}, $apps);

		return $apps;
	}

    /**
     * Find an app for a specific user by the app's slug.
     *
     * @param int $user_id The ID of the user.
     * @param string $slug The slug of the app.
     * @return array|null The app with matching slug for the user, or null if not found.
     */
    public function find_for_user( $user_id, $slug ) {
        $apps = $this->for_user( $user_id );

        // Filter the $apps array to find the item with matching slug.
        $filtered_apps = array_filter($apps, function ( $app ) use ( $slug ) {
            return $app['slug'] === $slug;
        });

        // array_filter preserves array keys, so use array_values to reindex it
        $filtered_apps = array_values( $filtered_apps );

        // Return the first app if one was found, otherwise return null
        return !empty( $filtered_apps ) ? $filtered_apps[0] : null;
    }

    /**
     * Find an app by slug.
     *
     * @param string $slug The slug of the app.
     * @return array|null The app with matching slug, or null if not found.
     */
    public function find( $slug ) {
        $apps = $this->all();

        // Filter the $apps array to find the item with matching slug.
        $filtered_apps = array_filter($apps, function ( $app ) use ( $slug ) {
            return $app['slug'] === $slug;
        });

        // array_filter preserves array keys, so use array_values to reindex it
        $filtered_apps = array_values( $filtered_apps );

        // Return the first app if one was found, otherwise return null
        return !empty( $filtered_apps ) ? $filtered_apps[0] : null;
    }

    /**
     * Merge a coded app into the apps array.
     * It should take precedence over any existing app with the same slug.
     * @param array $apps
     * @param array $app
     * @return void
     */
    private function merge_coded_app( array &$apps, array $app ) {
        $existing = $apps[ $app['slug'] ] ?? [];
        $apps[ $app['slug'] ] = array_merge( $existing, $app );
    }

    /**
     * Merge a db app into the apps array.
     * We need to be sure not to overwrite any existing coded app urls
     * and magic link meta
     * @param array $apps
     * @param array $app
     * @return void
     */
    private function merge_db_app( &$apps, $app ) {
        $existing = $apps[ $app['slug'] ] ?? [];
        $type = $existing['creation_type'] ?? 'custom';

        //If there is no existing app or the existing app is not a coded app, just merge the app
        if ( ( ! isset( $apps[ $app['slug'] ] ) )
            || ( $type !== 'code' ) ) {
            $apps[ $app['slug'] ] = array_merge( $existing, $app );
            return;
        }

        //If the existing app is a coded app, we need to keep the url and magic link meta
        $overrides = [
            'url' => $existing['url'] ?? ''
        ];
        if ( isset( $app['magic_link_meta'] ) ) {
            $overrides['magic_link_meta'] = $app['magic_link_meta'];
        }

        //Merge the app with the overrides
        $apps[ $app['slug'] ] = array_merge( $existing, $app, $overrides );
    }

    /**
     * Get all apps (inc soft if specified) data from the options and
     * ensure default values.
     *
     * @return array
     */

    public function get_all_apps_data( $is_soft = false ) {

        // Get the apps array from the option.
        $apps_collection = $this->all();

        // Filter accordingly by specified soft type.
        $apps_array = array_values( array_filter( $apps_collection, function ( $app ) use ( $is_soft ) {
            if ( !isset( $app['is_deleted'] ) ) {
                return !$is_soft;
            }

            return $is_soft === $app['is_deleted'];
        } ) );

        // Proceed with app array sort, merge and return.
        usort( $apps_array, function ( $a, $b ) {
            return (int) $a['sort'] - (int) $b['sort'];
        } );

        $apps_array = array_map( function ( $app ) {
            return array_merge( [
                'name'          => '',
                'type'          => 'Web View',
                'creation_type' => '',
                'icon'          => '',
                'url'           => '',
                'sort'          => 0,
                'slug'          => '',
                'is_hidden'     => false,
            ], $app );
        }, $apps_array );

        return $apps_array;
    }

    /**
     * Set hidden state of an app based on its slug, within admin settings.
     *
     * @param bool $hide The hidden state to be adopted.
     * @param array $params The route parameters.
     *
     * @return bool Boolean flag indicating whether hidden state change was successful.
     */

    public function handle_hidden_admin_state_change( $hide, $params ): bool {

        // Retrieve the existing array of apps
        $slug = $params['slug'] ?? '';
        if ( empty( $slug ) ) {
            return false;
        }

        $apps_array = $this->all();
        // Find the app with the specified ID and update its 'is_hidden' status
        foreach ( $apps_array as $key => $app ) {
            if ( isset( $app['slug'] ) && $app['slug'] == $slug ) {
                $apps_array[ $key ]['is_hidden'] = ( $hide ? 1 : 0 );
                break;
            }
        }
        // Save the updated array back to the option
        set_plugin_option( 'apps', $apps_array );

        return true;
    }

    /**
     * Set hidden state of an app based on its slug, within frontend view.
     *
     * @param bool $hide The hidden state to be adopted.
     * @param int $user_id The user_id to associate app updates to.
     * @param array $data The route parameters.
     *
     * @return bool Boolean flag indicating whether hidden state change was successful.
     */

    public function handle_hidden_view_state_change( $hide, $user_id, $data ): bool {
        $apps_array = $this->for_user( $user_id );

        // Find the app with the specified slug and update its 'is_hidden' status
        foreach ( $apps_array as $key => $app ) {
            if ( isset( $app['slug'] ) && $app['slug'] == $data['slug'] ) {
                $apps_array[$key]['is_hidden'] = ( $hide ? 1 : 0 );
                break;
            }
        }

        // Separate hidden and visible apps
        $hidden_apps  = [];
        $visible_apps = [];

        foreach ( $apps_array as $app ) {
            if ( $app['is_hidden'] == 1 ) {
                $hidden_apps[] = $app;
            } else {
                $visible_apps[] = $app;
            }
        }

        // Sort visible apps by the 'sort' field
        usort(
            $visible_apps,
            function ( $a, $b ) {
                return ( $a['sort'] <=> $b['sort'] );
            }
        );

        // Reset sort values for visible apps
        foreach ( $visible_apps as $index => $app ) {
            $visible_apps[$index]['sort'] = ( $index + 1 );
        }

        // Add hidden apps back to the end
        foreach ( $hidden_apps as $hidden_app ) {
            $hidden_app['sort'] = ( count( $visible_apps ) + 1 );
            $visible_apps[]     = $hidden_app;
        }

        // Save the updated array back to the option
        update_user_option( $user_id, 'dt_home_apps', $visible_apps );

        return true;
    }

    /**
     * Handle directional movement of apps within
     * admin list.
     *
     * @param string $direction The direction (up/down).
     * @param array $params The route parameters.
     *
     * @return bool Boolean flag indicating whether directional change was successful.
     */

    public function move( $direction, $params ): bool {
        $slug = $params['slug'] ?? '';
        if ( empty( $slug ) ) {
            return false;
        }

        // Retrieve the existing array of apps
        $apps_array = $this->all();

        // Find the index of the app and its current sort value
        $current_index = null;
        $current_sort  = null;
        foreach ( $apps_array as $key => $app ) {
            if ( $app['slug'] == $slug ) {
                $current_index = $key;
                $current_sort  = (int) $app['sort'];
                break;
            }
        }

        $save_updates = true;

        // Determine the maximum sort value
        $max_sort = count( $apps_array );

        switch ( $direction ) {
            case 'up':

                // Adjust the sort values
                foreach ( $apps_array as $key => &$app ) {
                    if ( $app['sort'] == $current_sort - 1 ) {
                        // Increment the sort value of the app that's currently one position above
                        $app['sort']++;
                    }
                }

                // Decrement the sort value of the current app
                if ( $current_sort > 0 ) {
                    $apps_array[ $current_index ]['sort']--;
                }

                break;

            case 'down':

                // Only proceed if the app was found and it's not already at the bottom
                if ( $current_index !== null && $current_sort < $max_sort ) {
                    // Adjust the sort values
                    foreach ( $apps_array as $key => &$app ) {
                        if ( $app['sort'] == (int) $current_sort + 1 ) {
                            // Decrement the sort value of the app that's currently one position below
                            $app['sort']--;
                        }
                    }
                    // Increment the sort value of the current app
                    $apps_array[ $current_index ]['sort']++;

                } else {
                    $save_updates = false;
                }

                break;
        }

        // Determine if changes are to be persisted.
        if ( $save_updates ) {

            // Normalize the sort values to ensure they are positive and sequential
            usort( $apps_array, function ( $a, $b ) {
                return (int) $a['sort'] - (int) $b['sort'];
            } );

            foreach ( $apps_array as $key => &$app ) {
                $app['sort'] = $key;
            }

            // Save the updated array back to the option
            set_plugin_option( 'apps', $apps_array );
        }

        return true;
    }
}
